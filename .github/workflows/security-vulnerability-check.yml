name: Security Vulnerability Check

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  check_vulnerabilities:
    name: Check for High/Critical Vulnerabilities
    runs-on: ubuntu-latest
    permissions:
      # Need security-events read permission to query vulnerabilities
      security-events: read
      # Need pull-requests write permission to comment on PRs
      pull-requests: write
      # Need contents read to access the repository
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check for High and Critical Vulnerabilities
        id: vulnerability_check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Get high and critical vulnerabilities from Dependabot alerts
            const dependabotAlerts = await github.rest.dependabot.listAlertsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              severity: ['high', 'critical']
            }).catch(error => {
              console.log('Error fetching Dependabot alerts:', error.message);
              return { data: [] };
            });
            
            // Get high and critical vulnerabilities from Code Scanning alerts
            const codeScanningAlerts = await github.rest.codeScanning.listAlertsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              severity: ['high', 'critical']
            }).catch(error => {
              console.log('Error fetching Code Scanning alerts:', error.message);
              return { data: [] };
            });
            
            // Get high and critical vulnerabilities from Secret Scanning alerts
            const secretScanningAlerts = await github.rest.secretScanning.listAlertsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            }).catch(error => {
              console.log('Error fetching Secret Scanning alerts:', error.message);
              return { data: [] };
            });
            
            // Combine all alerts
            const highCriticalVulnerabilities = [
              ...dependabotAlerts.data,
              ...codeScanningAlerts.data,
              ...secretScanningAlerts.data
            ];
            
            console.log(`Found ${highCriticalVulnerabilities.length} high/critical vulnerabilities`);
            
            if (highCriticalVulnerabilities.length > 0) {
              // Format alert information for the comment
              let alertDetails = '';
              
              // Process Dependabot alerts
              if (dependabotAlerts.data && dependabotAlerts.data.length > 0) {
                alertDetails += '### Dependabot Alerts\n\n';
                dependabotAlerts.data.forEach(alert => {
                  alertDetails += `- **${alert.security_vulnerability.severity.toUpperCase()}**: ${alert.security_advisory.summary} `;
                  alertDetails += `[View Alert](https://github.com/${context.repo.owner}/${context.repo.repo}/security/dependabot/${alert.number})\n`;
                  alertDetails += `  - Package: \`${alert.dependency.package.name}\`\n`;
                  alertDetails += `  - Vulnerable versions: ${alert.security_vulnerability.vulnerable_version_range}\n\n`;
                });
              }
              
              // Process Code Scanning alerts
              if (codeScanningAlerts.data && codeScanningAlerts.data.length > 0) {
                alertDetails += '### Code Scanning Alerts\n\n';
                codeScanningAlerts.data.forEach(alert => {
                  alertDetails += `- **${alert.rule.severity.toUpperCase()}**: ${alert.rule.description} `;
                  alertDetails += `[View Alert](https://github.com/${context.repo.owner}/${context.repo.repo}/security/code-scanning/${alert.number})\n`;
                  alertDetails += `  - Rule: \`${alert.rule.id}\`\n\n`;
                });
              }
              
              // Process Secret Scanning alerts
              if (secretScanningAlerts.data && secretScanningAlerts.data.length > 0) {
                alertDetails += '### Secret Scanning Alerts\n\n';
                secretScanningAlerts.data.forEach(alert => {
                  alertDetails += `- **HIGH**: Exposed secret detected: \`${alert.secret_type}\` `;
                  alertDetails += `[View Alert](https://github.com/${context.repo.owner}/${context.repo.repo}/security/secret-scanning/${alert.number})\n\n`;
                });
              }
              
              // Create the comment
              const comment = `## ⚠️ Security Vulnerability Alert ⚠️

This pull request is being submitted while there are ${highCriticalVulnerabilities.length} high or critical security vulnerabilities open in this repository.

${alertDetails}

Please address these vulnerabilities before merging this pull request.`;
              


              // Post comment on PR
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
              
              core.setFailed('High or critical security vulnerabilities detected');
              return false;
            } else {
              console.log('No high or critical vulnerabilities found');
              return true;
            }